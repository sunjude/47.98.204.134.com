<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="孙聚德">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="孙聚德">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="孙聚德">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 孙聚德 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">孙聚德</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">今日披星戴月，明日成就梦想！</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/10/MVVM With ReactiveCocoa/" itemprop="url">
                  MVVM With ReactiveCocoa
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-10T17:40:33+08:00" content="2016-04-10">
              2016-04-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/10/MVVM With ReactiveCocoa/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/10/MVVM With ReactiveCocoa/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://i1.piimg.com/709ccf65af2fcd9a.png" alt=""></p>
<p>作者： <a href="http://weibo.com/leichunfeng?is_hot=1" target="_blank" rel="external">@雷纯锋2011</a></p>
<hr>
<p>MVVM 是一种软件架构模式，它是 <a href="https://en.wikipedia.org/wiki/Model–view–viewmodel" target="_blank" rel="external">Martin Fowler</a> 的 <a href="http://martinfowler.com/eaaDev/PresentationModel.html" target="_blank" rel="external">Presentation Model</a> 的一种变体，最先由微软的架构师 John Gossman 在 2005 年提出，并应用在微软的 <a href="https://en.wikipedia.org/wiki/Windows_Presentation_Foundation" target="_blank" rel="external">WPF</a> 和 <a href="https://en.wikipedia.org/wiki/Microsoft_Silverlight" target="_blank" rel="external">Silverlight</a> 软件开发中。MVVM 衍生于 <a href="https://en.wikipedia.org/wiki/Model–view–controller" target="_blank" rel="external">MVC</a> ，是对 MVC 的一种演进，它促进了 UI 代码与业务逻辑的分离。</p>
<p>说明：本文将采用理论与实践相结合的方式，重点介绍一个使用 MVVM 和 RAC 开发的 iOS 开源项目 <a href="https://github.com/leichunfeng/MVVMReactiveCocoa" target="_blank" rel="external">MVVMReactiveCocoa</a> ，目的是希望能为你实践 MVVM 提供帮助。不过，在正式开始介绍正文之前，请你先思考以下三个问题：</p>
<pre><code>MVC 与 MVVM 有什么异同点，MVC 到 MVVM 是怎样演进的；
RAC 在 MVVM 中扮演什么样的角色，MVVM 是否一定要结合 RAC 使用；
如何将一个现有的 MVC 应用转变成一个 MVVM 应用，有哪些需要注意的地方。
</code></pre><p>带着以上问题，我们一起进入正文。</p>
<p>名词解释：本文中的 RAC 为 ReactiveCocoa 的缩写。    </p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC 是 iOS 开发中使用最普遍的架构模式，同时也是苹果官方推荐的架构模式。MVC 代表的是 Model–view–controller ，它们之间的关系如下：</p>
<p><img src="http://i2.piimg.com/7a6eb5736d54c10f.png" alt=""></p>
<p>是的，MVC 看上去棒极了，model 代表数据，view 代表 UI ，而 controller 则负责协调它们两者之间的关系。然而，尽管从技术上看 view 和 controller 是相互独立的，但事实上它们几乎总是结对出现，一个 view 只能与一个 controller 进行匹配，反之亦然。既然如此，那我们为何不将它们看作一个整体呢：<br><img src="http://i1.piimg.com/ffe42abedd02785e.png" alt=""></p>
<p>因此，M-VC 可能是对 iOS 中的 MVC 模式更为准确的解读。在一个典型的 MVC 应用中，controller 由于承载了过多的逻辑，往往会变得臃肿不堪，所以 MVC 也经常被人调侃成 Massive View Controller ：</p>
<p>iOS architecture, where MVC stands for Massive View Controller.</p>
<p>坦白说，有一部分逻辑确实是属于 controller 的，但是也有一部分逻辑是不应该被放置在 controller 中的。比如，将 model 中的 NSDate 转换成 view 可以展示的 NSString 等。在 MVVM 中，我们将这些逻辑统称为展示逻辑。</p>
<hr>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>因此，一种可以很好地解决 Massive View Controller 问题的办法就是将 controller 中的展示逻辑抽取出来，放置到一个专门的地方，而这个地方就是 viewModel 。其实，我们只要在上图中的 M-VC 之间放入 VM ，就可以得到 MVVM 模式的结构图：</p>
<p><img src="http://i3.piimg.com/3802a670a59395b8.png" alt=""></p>
<p>从上图中，我们可以非常清楚地看到 MVVM 中四个组件之间的关系。注：除了 view 、viewModel 和 model 之外，MVVM 中还有一个非常重要的隐含组件 binder ：</p>
<pre><code>view ：由 MVC 中的 view 和 controller 组成，负责 UI 的展示，绑定 viewModel 中的属性，触发 viewModel 中的命令；
viewModel ：从 MVC 的 controller 中抽取出来的展示逻辑，负责从 model 中获取 view 所需的数据，转换成 view 可以展示的数据，并暴露公开的属性和命令供 view 进行绑定；
model ：与 MVC 中的 model 一致，包括数据模型、访问数据库的操作和网络请求等；
binder ：在 MVVM 中，声明式的数据和命令绑定是一个隐含的约定，它可以让开发者非常方便地实现 view 和 viewModel 的同步，避免编写大量繁杂的样板化代码。在微软的 MVVM 实现中，使用的是一种被称为 XAML 的标记语言。
</code></pre><p><a href="https://en.wikipedia.org/wiki/Extensible_Application_Markup_Language" target="_blank" rel="external">XAML</a></p>
<hr>
<h2 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a>ReactiveCocoa</h2><p>尽管，在 iOS 开发中，系统并没有提供类似的框架可以让我们方便地实现 binder 功能，不过，值得庆幸的是，GitHub 开源的 RAC ，给了我们一个非常不错的选择。</p>
<p>RAC 是一个 iOS 中的函数式响应式编程框架，它受 <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="external">Functional Reactive Programming</a> 的启发，是 <a href="https://github.com/jspahrsummers" target="_blank" rel="external">Justin Spahr-Summers</a> 和 <a href="https://github.com/joshaber" target="_blank" rel="external">Josh Abernathy</a> 在开发 <a href="https://desktop.github.com" target="_blank" rel="external">GitHub for Mac</a> 过程中的一个副产品，它提供了一系列用来组合和转换值流的 API 。如需了解更多关于 RAC 的信息，可以阅读我的上一篇文章<a href="http://blog.leichunfeng.com/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/" target="_blank" rel="external">《ReactiveCocoa v2.5 源码解析之架构总览》</a>。</p>
<p>在 iOS 的 MVVM 实现中，我们可以使用 RAC 来在 view 和 viewModel 之间充当 binder 的角色，优雅地实现两者之间的同步。此外，我们还可以把 RAC 用在 model 层，使用 Signal 来代表异步的数据获取操作，比如读取文件、访问数据库和网络请求等。说明，RAC 的后一个应用场景是与 MVVM 无关的，也就是说，我们同样可以在 MVC 的 model 层这么用。</p>
<hr>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>综上所述，我们只要将 MVC 中的 controller 中的展示逻辑抽取出来，放置到 viewModel 中，然后通过一定的技术手段，比如 RAC 来同步 view 和 viewModel ，就完成了 MVC 到 MVVM 的转变。</p>
<p>Talk is cheap. Show me the code.</p>
<p>下面，我们直接上代码，一起来看一个 MVC 模式转换成 MVVM 模式的示例。首先是 model 层的代码 Person ：</p>
<pre><code>@interface Person : NSObject

- (instancetype)initwithSalutation:(NSString *)salutation firstName:(NSString *)firstName lastName:(NSString *)lastName birthdate:(NSDate *)birthdate;

@property (nonatomic, copy, readonly) NSString *salutation;
@property (nonatomic, copy, readonly) NSString *firstName;
@property (nonatomic, copy, readonly) NSString *lastName;
@property (nonatomic, copy, readonly) NSDate *birthdate;

@end
</code></pre><p>然后是 view 层的代码 PersonViewController ，在 viewDidLoad 方法中，我们将 Person 中的属性进行一定的转换后，赋值给相应的 view 进行展示：</p>
<pre><code>- (void)viewDidLoad {
[super viewDidLoad];

if (self.model.salutation.length &gt; 0) {
    self.nameLabel.text = [NSString stringWithFormat:@&quot;%@ %@ %@&quot;, self.model.salutation, self.model.firstName, self.model.lastName];
} else {
    self.nameLabel.text = [NSString stringWithFormat:@&quot;%@ %@&quot;, self.model.firstName, self.model.lastName];
}

NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
[dateFormatter setDateFormat:@&quot;EEEE MMMM d, yyyy&quot;];
self.birthdateLabel.text = [dateFormatter stringFromDate:model.birthdate];
}
</code></pre><p>接下来，我们引入一个 viewModel ，将 PersonViewController 中的展示逻辑抽取到这个 PersonViewModel 中：</p>
<pre><code>@interface PersonViewModel : NSObject

- (instancetype)initWithPerson:(Person *)person;

@property (nonatomic, strong, readonly) Person *person;
@property (nonatomic, copy, readonly) NSString *nameText;
@property (nonatomic, copy, readonly) NSString *birthdateText;

@end

@implementation PersonViewModel

- (instancetype)initWithPerson:(Person *)person {
self = [super init];
if (self) {
   _person = person;

  if (person.salutation.length &gt; 0) {
      _nameText = [NSString stringWithFormat:@&quot;%@ %@ %@&quot;, self.person.salutation, self.person.firstName, self.person.lastName];
  } else {
      _nameText = [NSString stringWithFormat:@&quot;%@ %@&quot;, self.person.firstName, self.person.lastName];
  }

  NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
  [dateFormatter setDateFormat:@&quot;EEEE MMMM d, yyyy&quot;];
  _birthdateText = [dateFormatter stringFromDate:person.birthdate];
}
return self;
}

@end
</code></pre><p>最终，PersonViewController 将会变得非常轻量级：</p>
<pre><code>- (void)viewDidLoad {
[super viewDidLoad];

self.nameLabel.text = self.viewModel.nameText;
self.birthdateLabel.text = self.viewModel.birthdateText;
}
</code></pre><p>怎么样？其实 MVVM 并没有想像中的那么难吧，而且更重要的是它也没有破坏 MVC 的现有结构，只不过是移动了一些代码，仅此而已。好了，说了这么多，那 MVVM 相比 MVC 到底有哪些好处呢？我想，主要可以归纳为以下三点：</p>
<p>由于展示逻辑被抽取到了 viewModel 中，所以 view 中的代码将会变得非常轻量级；<br>由于 viewModel 中的代码是与 UI 无关的，所以它具有良好的可测试性；<br>对于一个封装了大量业务逻辑的 model 来说，改变它可能会比较困难，并且存在一定的风险。在这种场景下，viewModel 可以作为 model 的适配器使用，从而避免对 model 进行较大的改动。<br>通过前面的示例，我们对第一点已经有了一定的感触；至于第三点，可能对于一个复杂的大型应用来说，才会比较明显；下面，我们还是使用前面的示例，来直观地感受下第二点好处：</p>
<pre><code>SpecBegin(Person)
NSString *salutation = @&quot;Dr.&quot;;
NSString *firstName = @&quot;first&quot;;
NSString *lastName = @&quot;last&quot;;
NSDate *birthdate = [NSDate dateWithTimeIntervalSince1970:0];

it (@&quot;should use the salutation available. &quot;, ^{
    Person *person = [[Person alloc] initWithSalutation:salutation firstName:firstName lastName:lastName birthdate:birthdate];
    PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person];
    expect(viewModel.nameText).to.equal(@&quot;Dr. first last&quot;);
});

it (@&quot;should not use an unavailable salutation. &quot;, ^{
    Person *person = [[Person alloc] initWithSalutation:nil firstName:firstName lastName:lastName birthdate:birthdate];
    PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person];
    expect(viewModel.nameText).to.equal(@&quot;first last&quot;);
});

it (@&quot;should use the correct date format. &quot;, ^{
    Person *person = [[Person alloc] initWithSalutation:nil firstName:firstName lastName:lastName birthdate:birthdate];
    PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person];
    expect(viewModel.birthdateText).to.equal(@&quot;Thursday January 1, 1970&quot;);
});
SpecEnd
</code></pre><p>对于 MVVM 来说，我们可以把 view 看作是 viewModel 的可视化形式，viewModel 提供了 view 所需的数据和命令。因此，viewModel 的可测试性可以帮助我们极大地提高应用的质量。</p>
<hr>
<h2 id="MVVMReactiveCocoa"><a href="#MVVMReactiveCocoa" class="headerlink" title="MVVMReactiveCocoa"></a>MVVMReactiveCocoa</h2><p>接下来，我们进入本文的第二部分，重点介绍一个使用 MVVM 和 RAC 开发的开源项目 MVVMReactiveCocoa 。说明，本文将主要介绍这个应用的架构和设计思路，希望可以为你实践 MVVM 提供一个真实的参考案例，有些架构并非是 MVVM 所必须的，而是我们为了更顺畅地使用 MVVM 而引入的，特别是 ViewModel-Based Navigation 。所以，请你在实践的过程中能够结合自身应用的实际情况做出相应的取舍，灵活处理。最后，我们将以登录界面为例，一起探讨下 MVVM 的实践思路。</p>
<p>说明，以下内容均基于 MVVMReactiveCocoa 的 v2.1.1 标签进行展开，并且对部分无关代码做了删减。</p>
<p>类图</p>
<p>为了方便我们从宏观上了解 MVVMReactiveCocoa 的整体结构，我们先来看看它的类图：</p>
<p><img src="http://i2.piimg.com/2841d0831802a8c7.png" alt=""></p>
<p>MVVMReactiveCocoa-v2.1.1</p>
<p>从上图中，我们可以看到，在 MVVMReactiveCocoa 中主要有两大继承体系：</p>
<pre><code>用蓝色标识出来的 viewModel 的继承体系，基类为 MRCViewModel ；
用红色标识出来的 view 的继承体系，基类为 MRCViewController 。
</code></pre><p>除了提供与系统基类 UIViewController 相对应的基类 MRCViewModel/MRCViewController 外，还提供了与系统基类 UITableViewController 和 UITabBarController 相对应的基类 MRCTableViewModel/MRCTableViewController 和 MRCTabBarViewModel/MRCTabBarController ，其中基类 MRCTableViewModel/MRCTableViewController 的使用最为普遍。</p>
<p>说明，之所以通过基类的方式来组织 MVVMReactiveCocoa ，一方面是因为主要开发者只有我一个人，这个方案非常容易实施；另一方面是因为通过基类的方式可以尽可能简单地实现代码重用，提高开发效率。</p>
<p>服务总线</p>
<p>经过前面的探讨，我们已经知道了 MVVM 中的 viewModel 的主要职责就是从 model 层获取 view 所需的数据，并且将这些数据转换成 view 能够展示的形式。因此，为了方便 viewModel 层调用 model 层中的所有服务，并且统一管理这些服务的创建，我使用抽象工厂模式将 model 层的所有服务集中管理了起来，结构图如下：</p>
<p><img src="http://i2.piimg.com/5008bac28eccafa0.png" alt=""></p>
<p>从上图中，我们可以看出，在服务总线类 MRCViewModelServices/MRCViewModelServicesImpl 中，主要包括以下三个方面的内容：</p>
<pre><code>应用自有的服务类，用柚黄色进行了标识，包括 MRCAppStoreService/MRCAppStoreServiceImpl 和 MRCRepositoryService/MRCRepositoryServiceImpl 两个服务类；

第三方 GitHub 提供的 API 框架，用天蓝色进行了标识，主要包括 OCTClient 服务类；

应用的导航服务，用藻绿色进行了标识，包括 MRCNavigationProtocol 协议和实现类 MRCViewModelServicesImpl 等。
</code></pre><p>其中，前两者都是以信号的形式对 viewModel 层提供服务，代表异步的网络请求等数据获取操作，而我们在 viewModel 层则可以通过订阅信号的形式获取到所需的数据。此外，服务总线还实现了 MRCNavigationProtocol 协议，它的内容如下：</p>
<pre><code>@protocol MRCNavigationProtocol [NSObject]（因识别问题，这里用方括号代替尖括号）

- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated;

- (void)popViewModelAnimated:(BOOL)animated;

- (void)popToRootViewModelAnimated:(BOOL)animated;

- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion;

- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion;

- (void)resetRootViewModel:(MRCViewModel *)viewModel;

@end
</code></pre><p>看上去是不是有点眼熟？是的，MRCNavigationProtocol 协议其实就是参照系统的导航操作定义出来的，用来实现 ViewModel-Based 的导航服务。注意，服务总线类 MRCViewModelServicesImpl 其实并没有真正实现 MRCNavigationProtocol 协议中声明的操作，只不过是实现了一些空操作而已：</p>
<pre><code>- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated {}

- (void)popViewModelAnimated:(BOOL)animated {}

- (void)popToRootViewModelAnimated:(BOOL)animated {}

- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion {}

- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion {}

- (void)resetRootViewModel:(MRCViewModel *)viewModel {}
</code></pre><p>那么，我们是怎么实现 ViewModel-Based 的导航操作的呢？用 MRCViewModelServicesImpl 来实现这些空操作到底有什么用意？为什么要这么做，目的是为了什么？兄台，莫急，请接着看下一小节的内容。</p>
<h3 id="ViewModel-Based-Navigation"><a href="#ViewModel-Based-Navigation" class="headerlink" title="ViewModel-Based Navigation"></a>ViewModel-Based Navigation</h3><p>我们先来思考一个问题，就是我们为什么要实现 ViewModel-Based 的导航操作呢？直接在 view 层使用系统的 push/present 等操作来完成导航不就好了么？我总结了一下这么做的理由，主要有以下三点：</p>
<pre><code>从理论上来说，MVVM 模式的应用应该是以 viewModel 为驱动来运转的；

根据我们前面对 MVVM 的探讨，viewModel 提供了 view 所需的数据和命令。因此，我们往往可以直接在命令执行成功后使用 doNext 顺带就把导航操作给做了，一气呵成；

这样可以使 view 更加轻量级，只需要绑定 viewModel 提供的数据和命令即可。
</code></pre><p>既然如此，那我们究竟要如何实现 ViewModel-Based 的导航操作呢？我们都知道 iOS 中的导航操作无外乎两种，push/pop 和 present/dismiss ，前者是 UINavigationController 特有的功能，而后者是所有 UIViewController 都具备的功能。注意，UINavigationController 也是 UIViewController 的子类，所以它也同样具备 present/dismiss 的功能。因此，从本质上来说，不管我们要实现什么样的导航操作，最终都是离不开 push/pop 和 present/dismiss 的。</p>
<p>目前，MVVMReactiveCocoa 的做法是在 view 层维护一个 NavigationController 的堆栈 MRCNavigationControllerStack ，不管是 push/pop 还是 present/dismiss ，都使用栈顶的 NavigationController 来执行导航操作，并且保证 present 出来的是一个 NavigationController 。</p>
<p>接下来，我们一起来看看 MVVMReactiveCocoa 在执行了 push/pop 或 present/dismiss 操作后视图层次结构的变化过程。首先，我们来看看用户在登录成功后进入到首页时应用的视图层次结构图：</p>
<p><img src="http://i3.piimg.com/9708bd1107ab7298.png" alt=""></p>
<p>此时，应用展示的界面是 NewsViewController 。在 MRCNavigationControllerStack 堆栈中只有 NavigationController0 一个元素；而 NavigationController1 并没有在 MRCNavigationControllerStack 堆栈中，这是因为需要支持 TabBarController 的滑动切换而设计的视图层次结构，是首页比较特殊的一个地方。更多信息可以查看 GitHub 开源库 WXTabBarController ，在这里，我们不用太过于关心这个问题，只需要理解原理就好了。</p>
<p>接下来，当用户在 NewsViewController 界面，点击了某一个 cell ，通过 push 的方式，进入到仓库详情界面时，应用的视图层次结构图如下：</p>
<p><img src="http://i1.piimg.com/ddc3e6256277dd77.png" alt=""></p>
<p>应用通过 MRCNavigationControllerStack 栈顶的元素 NavigationController0 ，将仓库详情界面 push 到了自身的堆栈中。此时，应用展示的界面是被 push 进来的仓库详情界面 RepoDetailViewController 。最后，当用户在仓库详情界面，点击左下角的切换分支按钮，通过 present 的方式，弹出分支选择界面时，应用的视图层次结构图如下：</p>
<p><img src="http://i1.piimg.com/eb734473a11c79f1.png" alt=""></p>
<p>应用通过 MRCNavigationControllerStack 栈顶的元素 NavigationController0 ，将 NavigationController5 以 present 的方式弹出来。此时，应用展示的是 NavigationController5 的根视图 SelectBranchOrTagViewController 。说明，由于 pop 和 dismiss 与 push 和 present 互为逆操作，所以只要按照从下到上的顺序看上面的视图层次结构图即可，这里不再赘述。</p>
<p>等等，如果我没有记错的话，MRCNavigationControllerStack 堆栈是在 view 层，而服务总线类 MRCViewModelServicesImpl 是在 viewModel 层的。据我所知，viewModel 层是不能引入 view 层的任何东西的，更严格的说，是不能引入任何 UIKit 中的东西的，否则就违背了 MVVM 的基本原则，并且也会散失 viewModel 的可测试性。在这个前提下，你要如何让这两者产生关联呢？</p>
<p>没错，这就是 MRCViewModelServicesImpl 中之所以实现那些空操作的目的所在了。viewModel 通过调用 MRCViewModelServicesImpl 中的空操作来表明需要执行相应的导航操作，而 MRCNavigationControllerStack 则通过 Hook 来捕获这些空操作，然后使用栈顶的 NavigationController 来执行真正的导航操作：</p>
<pre><code>- (void)registerNavigationHooks {
@weakify(self)
[[(NSObject *)self.services
    rac_signalForSelector:@selector(pushViewModel:animated:)]
    subscribeNext:^(RACTuple *tuple) {
        @strongify(self)
        UIViewController *viewController = (UIViewController *)[MRCRouter.sharedInstance viewControllerForViewModel:tuple.first];
        [self.navigationControllers.lastObject pushViewController:viewController animated:[tuple.second boolValue]];
    }];

[[(NSObject *)self.services
    rac_signalForSelector:@selector(popViewModelAnimated:)]
    subscribeNext:^(RACTuple *tuple) {
      @strongify(self)
        [self.navigationControllers.lastObject popViewControllerAnimated:[tuple.first boolValue]];
    }];

[[(NSObject *)self.services
    rac_signalForSelector:@selector(popToRootViewModelAnimated:)]
    subscribeNext:^(RACTuple *tuple) {
        @strongify(self)
        [self.navigationControllers.lastObject popToRootViewControllerAnimated:[tuple.first boolValue]];
    }];

[[(NSObject *)self.services
    rac_signalForSelector:@selector(presentViewModel:animated:completion:)]
    subscribeNext:^(RACTuple *tuple) {
      @strongify(self)
        UIViewController *viewController = (UIViewController *)[MRCRouter.sharedInstance viewControllerForViewModel:tuple.first];

        UINavigationController *presentingViewController = self.navigationControllers.lastObject;
        if (![viewController isKindOfClass:UINavigationController.class]) {
            viewController = [[MRCNavigationController alloc] initWithRootViewController:viewController];
        }
        [self pushNavigationController:(UINavigationController *)viewController];
        [presentingViewController presentViewController:viewController animated:[tuple.second boolValue] completion:tuple.third];
    }];

[[(NSObject *)self.services
    rac_signalForSelector:@selector(dismissViewModelAnimated:completion:)]
    subscribeNext:^(RACTuple *tuple) {
        @strongify(self)
        [self popNavigationController];
        [self.navigationControllers.lastObject dismissViewControllerAnimated:[tuple.first boolValue] completion:tuple.second];
    }];

[[(NSObject *)self.services
    rac_signalForSelector:@selector(resetRootViewModel:)]
    subscribeNext:^(RACTuple *tuple) {
        @strongify(self)
        [self.navigationControllers removeAllObjects];

        UIViewController *viewController = (UIViewController *)[MRCRouter.sharedInstance viewControllerForViewModel:tuple.first];
        if (![viewController isKindOfClass:[UINavigationController class]]) {
            viewController = [[MRCNavigationController alloc] initWithRootViewController:viewController];
            ((UINavigationController *)viewController).delegate = self;
            [self pushNavigationController:(UINavigationController *)viewController];
        }

        MRCSharedAppDelegate.window.rootViewController = viewController;
    }];
}
</code></pre><p>通过 Hook 的方式，我们最终实现了 ViewModel-Based 的导航操作，并且在 viewModel 层中也没有引入 view 层的任意东西，实现了解耦合。</p>
<hr>
<h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>还有一点值得一提的是，我们在 viewModel 中调用导航操作的时候，只传入了 viewModel 的实例作为参数，那么我们在 MRCNavigationControllerStack 中执行真正的导航操作时，怎么才能知道要跳转到哪个界面呢？为此，我们配置了一个从 viewModel 到 view 的映射，并且约定了一个统一的初始化 view 的方法 initWithViewModel: ：</p>
<pre><code>- (MRCViewController *)viewControllerForViewModel:(MRCViewModel *)viewModel {
NSString *viewController = self.viewModelViewMappings[NSStringFromClass(viewModel.class)];

NSParameterAssert([NSClassFromString(viewController) isSubclassOfClass:[MRCViewController class]]);
NSParameterAssert([NSClassFromString(viewController) instancesRespondToSelector:@selector(initWithViewModel:)]);

return [[NSClassFromString(viewController) alloc] initWithViewModel:viewModel];
}

- (NSDictionary *)viewModelViewMappings {
return @{
  @&quot;MRCLoginViewModel&quot;: @&quot;MRCLoginViewController&quot;,
    @&quot;MRCHomepageViewModel&quot;: @&quot;MRCHomepageViewController&quot;,
    @&quot;MRCRepoDetailViewModel&quot;: @&quot;MRCRepoDetailViewController&quot;,
    ...
};
}
</code></pre><h3 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h3><p>最后，我们一起来看看登录界面中 viewModel 和 view 的部分关键代码，探讨一下 MVVM 的具体实践过程。说明，我们将会尽可能地回避具体的业务逻辑，重点关注 MVVM 的实践思路。下面是登录界面的截图：</p>
<p><img src="http://i3.piimg.com/53eb7da6a46df21e.jpg" alt=""></p>
<p>其中，主要的界面元素有：</p>
<pre><code>一个用于展示用户头像的按钮 avatarButton ；

用于输入账号和密码的输入框 usernameTextField 和 passwordTextField ；

一个直接登录的按钮 loginButton 和一个跳转到浏览器授权登录的按钮 browserLoginButton 。
</code></pre><p>分析：根据我们前面对 MVVM 的探讨，viewModel 需要提供 view 所需的数据和命令。因此，MRCLoginViewModel.h 头文件的内容大致如下：</p>
<pre><code>@interface MRCLoginViewModel : MRCViewModel

@property (nonatomic, copy, readonly) NSURL *avatarURL;
@property (nonatomic, copy) NSString *username;
@property (nonatomic, copy) NSString *password;

@property (nonatomic, strong, readonly) RACSignal *validLoginSignal;
@property (nonatomic, strong, readonly) RACCommand *loginCommand;
@property (nonatomic, strong, readonly) RACCommand *browserLoginCommand;

@end
</code></pre><p>非常直观，其中需要特别说明的是 validLoginSignal 属性代表的是登录按钮是否可用，它将会与 view 中登录按钮的 enabled 属性进行绑定。接着，我们来看看 MRCLoginViewModel.m 的实现文件中的部分关键代码：</p>
<pre><code>@implementation MRCLoginViewController

- (void)bindViewModel {
[super bindViewModel];

@weakify(self)
[RACObserve(self.viewModel, avatarURL) subscribeNext:^(NSURL *avatarURL) {
  @strongify(self)
    [self.avatarButton sd_setImageWithURL:avatarURL forState:UIControlStateNormal placeholderImage:[UIImage imageNamed:@&quot;default-avatar&quot;]];
}];

RAC(self.viewModel, username)  = self.usernameTextField.rac_textSignal;
RAC(self.viewModel, password)  = self.passwordTextField.rac_textSignal;
RAC(self.loginButton, enabled) = self.viewModel.validLoginSignal;

[[self.loginButton
    rac_signalForControlEvents:UIControlEventTouchUpInside]
    subscribeNext:^(id x) {
        @strongify(self)
        [self.viewModel.loginCommand execute:nil];
    }];

[[self.browserLoginButton
    rac_signalForControlEvents:UIControlEventTouchUpInside]
    subscribeNext:^(id x) {
        @strongify(self)
        NSString *message = [NSString stringWithFormat:@&quot;“%@” wants to open “Safari”&quot;, MRC_APP_NAME];

        UIAlertController *alertController = [UIAlertController alertControllerWithTitle:nil
                                                                                 message:message
                                                                          preferredStyle:UIAlertControllerStyleAlert];

        [alertController addAction:[UIAlertAction actionWithTitle:@&quot;Cancel&quot; style:UIAlertActionStyleCancel handler:NULL]];
        [alertController addAction:[UIAlertAction actionWithTitle:@&quot;Open&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
            @strongify(self)
            [self.viewModel.browserLoginCommand execute:nil];
        }]];

        [self presentViewController:alertController animated:YES completion:NULL];
    }];
} 

@end
</code></pre><hr>
<pre><code>当用户输入的用户名发生变化时，调用 model 层的方法查询本地数据库中缓存的用户数据，并返回 avatarURL 属性;

当用户输入的用户名或密码发生变化时，判断用户名和密码的长度是否均大于 0 ，如果是则登录按钮可用，否则不可用;

当 loginCommand 或 browserLoginCommand 命令执行成功时，调用 doNext 代码块，使用服务总线中的方法 resetRootViewModel: 进入首页。
</code></pre><p>接下来，我们来看看 MRCLoginViewController 中的部分关键代码：</p>
<pre><code>@implementation MRCLoginViewController

- (void)bindViewModel {
[super bindViewModel];

@weakify(self)
[RACObserve(self.viewModel, avatarURL) subscribeNext:^(NSURL *avatarURL) {
  @strongify(self)
    [self.avatarButton sd_setImageWithURL:avatarURL forState:UIControlStateNormal placeholderImage:[UIImage imageNamed:@&quot;default-avatar&quot;]];
}];

RAC(self.viewModel, username)  = self.usernameTextField.rac_textSignal;
RAC(self.viewModel, password)  = self.passwordTextField.rac_textSignal;
RAC(self.loginButton, enabled) = self.viewModel.validLoginSignal;

[[self.loginButton
    rac_signalForControlEvents:UIControlEventTouchUpInside]
    subscribeNext:^(id x) {
        @strongify(self)
        [self.viewModel.loginCommand execute:nil];
    }];

[[self.browserLoginButton
    rac_signalForControlEvents:UIControlEventTouchUpInside]
    subscribeNext:^(id x) {
        @strongify(self)
        NSString *message = [NSString stringWithFormat:@&quot;“%@” wants to open “Safari”&quot;, MRC_APP_NAME];

        UIAlertController *alertController = [UIAlertController alertControllerWithTitle:nil
                                                                                 message:message
                                                                          preferredStyle:UIAlertControllerStyleAlert];

        [alertController addAction:[UIAlertAction actionWithTitle:@&quot;Cancel&quot; style:UIAlertActionStyleCancel handler:NULL]];
        [alertController addAction:[UIAlertAction actionWithTitle:@&quot;Open&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {
            @strongify(self)
            [self.viewModel.browserLoginCommand execute:nil];
        }]];
        [self presentViewController:alertController animated:YES completion:NULL];
    }];
}


@end
</code></pre><hr>
<pre><code>观察 viewModel 中 avatarURL 属性的变化，然后设置 avatarButton 中的图片；

将 viewModel 中的 username 和 password 属性分别与 usernameTextField 和 passwordTextField 输入框中的内容进行绑定；

将 loginButton 的 enabled 属性与 viewM    odel 的 validLoginSignal 属性进行绑定；

在 loginButton 和 browserLoginButton 按钮被点击时分别执行 loginCommand 和 browserLoginCommand 命令。
</code></pre><p>综上所述，我们将 MRCLoginViewController 中的展示逻辑抽取到 MRCLoginViewModel 中后，使得 MRCLoginViewController 中的代码更加简洁和清晰。实践 MVVM 的关键点在于，我们要能够分析清楚 viewModel 需要暴露给 view 的数据和命令，这些数据和命令能够代表 view 当前的状态。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先，我们从理论出发介绍了 MVC 和 MVVM 各自的概念以及从 MVC 到 MVVM 的演进过程；接着，介绍了 RAC 在 MVVM 中的两个使用场景；最后，我们从实践的角度，重点介绍了一个使用 MVVM 和 RAC 开发的开源项目 MVVMReactiveCocoa 。总的来说，我认为 iOS 中的 MVVM 可以分为以下三种不同的实践程度，它们分别对应不同的适用场景：</p>
<pre><code>MVVM + KVO ，适用于现有的 MVC 项目，想转换成 MVVM 但是不打算引入 RAC 作为 binder 的团队；

MVVM + RAC ，适用于现有的 MVC 项目，想转换成 MVVM 并且打算引入 RAC 作为 binder 的团队；

MVVM + RAC + ViewModel-Based Navigation ，适用于全新的项目，想实践 MVVM 并且打算引入 RAC 作为 binder ，然后也想实践 ViewModel-Based Navigation 的团队。
</code></pre><p>写在最后，希望这篇文章能够打消你对 MVVM 模式的顾虑，赶快行动起来吧。</p>
<p>参考链接:</p>
<p><a href="https://www.objc.io/issues/13-architecture/mvvm/" target="_blank" rel="external">https://www.objc.io/issues/13-architecture/mvvm/</a></p>
<p><a href="https://msdn.microsoft.com/en-us/library/hh848246.aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/hh848246.aspx</a></p>
<p><a href="https://en.wikipedia.org/wiki/Model–view–viewmodel" target="_blank" rel="external">https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel</a></p>
<p><a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.54had8ccn" target="_blank" rel="external">https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.p6n56kyc4</a></p>
<p><a href="http://cocoasamurai.blogspot.ru/2013/03/basic-mvvm-with-reactivecocoa.html" target="_blank" rel="external">http://cocoasamurai.blogspot.ru/2013/03/basic-mvvm-with-reactivecocoa.html</a></p>
<p><a href="http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction/" target="_blank" rel="external">http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction/</a></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/01/iOS公司开发者账号申请记录/" itemprop="url">
                  iOS公司开发者账号申请记录
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-01T21:22:52+08:00" content="2016-03-01">
              2016-03-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS开发者账号/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发者账号</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/01/iOS公司开发者账号申请记录/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/01/iOS公司开发者账号申请记录/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="账号类型"><a href="#账号类型" class="headerlink" title="账号类型"></a>账号类型</h3><ul>
<li>个人账号(individual)：个人申请用于开发苹果app所使用的账号，仅限于个人使用，申请比较容易。 $99</li>
<li>公司账号(Company)：以公司的名义申请的开发者账号，用于公司内部的开发者共用，申请流程相对比较麻烦需要使用到邓白氏编码。最多添加100个设备UDID测试。 $99</li>
<li>企业账号(Enterprise)：一般是公司规模在500人以上的企业，用于内部测试发布的账号，该账号发布的应用不发布在appstore上，只能企业内部使用。不限制设备的数量。 $299</li>
<li>高校账号(University): 高校计划需要提供高校基本信息，在注册方式上苹果开发者官网有详细的流程。免费使用，不可以发布到Apple store。
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/03/01/iOS公司开发者账号申请记录/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/21/UIImagePicker拍照/" itemprop="url">
                  UIImagePicker拍照
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-21T21:15:45+08:00" content="2015-12-21">
              2015-12-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS功能篇/" itemprop="url" rel="index">
                    <span itemprop="name">iOS功能篇</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/21/UIImagePicker拍照/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/21/UIImagePicker拍照/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>关于如何使用UIImagePickerController来拍照和录制视频，下面的程序中只要将_isVideo设置为YES就是视频录制模式，录制完后在主视图控制器中自动播放；如果将_isVideo设置为NO则为拍照模式，拍照完成之后在主视图控制器中显示拍摄的照片：<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/12/21/UIImagePicker拍照/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/15/UITableViewCell的自定义以及重用/" itemprop="url">
                  UITableViewCell的自定义以及重用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-06-15T20:52:44+08:00" content="2015-06-15">
              2015-06-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS新手进阶篇/" itemprop="url" rel="index">
                    <span itemprop="name">iOS新手进阶篇</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/06/15/UITableViewCell的自定义以及重用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/15/UITableViewCell的自定义以及重用/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>在UITableView中，我们通常来展示各色各样的信息，这时，系统自带的cell形式就无法满足我们的需求了。此时，我们就需要用到自定义cell。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/06/15/UITableViewCell的自定义以及重用/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/13/UITableView的编辑和移动/" itemprop="url">
                  UITableView的编辑和移动
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-06-13T13:42:36+08:00" content="2015-06-13">
              2015-06-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS新手进阶篇/" itemprop="url" rel="index">
                    <span itemprop="name">iOS新手进阶篇</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/06/13/UITableView的编辑和移动/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/13/UITableView的编辑和移动/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>上一篇记录了UITableView基本的用法，包括创建、设置代理以及代理方法的实现。这一篇来记录一下UITableView的编辑和移动。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/06/13/UITableView的编辑和移动/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/11/UITableView/" itemprop="url">
                  UITableView
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-06-11T20:49:05+08:00" content="2015-06-11">
              2015-06-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS新手进阶篇/" itemprop="url" rel="index">
                    <span itemprop="name">iOS新手进阶篇</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/06/11/UITableView/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/11/UITableView/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>今天写一下UITableView控件以及一个使用率非常高的视图控制器UITableViewController</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>UITableView经常被用来展示一系列相似的信息，有点类似于平时所见的列表，它有两种形式，一种为UITableViewStylePlain，另一种为UITableViewStyleGrouped。其实二者没有多大差别，第二种只是在第一种的基础上按分组进行显示。我们平时常用第二种形式。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/06/11/UITableView/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/04/Xcode快捷键/" itemprop="url">
                  Xcode快捷键
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-06-04T23:23:43+08:00" content="2015-06-04">
              2015-06-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Xcode辅助工具/" itemprop="url" rel="index">
                    <span itemprop="name">Xcode辅助工具</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/06/04/Xcode快捷键/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/04/Xcode快捷键/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>作为一名 ‘iOS开发工程师’，你应该学会熟练的使用XCode进行代码编写，所以建议大家去使用快捷键进行开发，因为：</p>
<ol>
<li>可以让我们显得更加的专业，逼格更高</li>
<li>提高我们的开发效率，节省开发时间</li>
<li>使用任何人的电脑将熟练，快速的操作（不建议大家更改系统自带的快捷按键）</li>
</ol>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/06/04/Xcode快捷键/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/11/CocoaPosd详解/" itemprop="url">
                  CocoaPosd详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-11T21:16:01+08:00" content="2015-05-11">
              2015-05-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Xcode辅助工具/" itemprop="url" rel="index">
                    <span itemprop="name">Xcode辅助工具</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/05/11/CocoaPosd详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/11/CocoaPosd详解/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="http://ww4.sinaimg.cn/large/9c2363adgw1es45z04v3dj20x40li0v3.jpg" alt=""></p>
<h3 id="CocoaPosd是什么？"><a href="#CocoaPosd是什么？" class="headerlink" title="CocoaPosd是什么？"></a>CocoaPosd是什么？</h3><p>当我们开发iOS项目时候，会经常使用到第三方类库，并且会使用很多。</p>
<p>大家的做法基本上都是到GitHub上下载一个一个的类库，然后导入到工程中，并且引入各种的类库，做各种的配置。有时候还要处理ARC与MRC的问题，很麻烦。</p>
<p>还有一种情况，就是当第三方类库出现升级的情况时候，我们还需要删掉旧的，下载新的，再重新导入。</p>
<p>以上问题超级的烦人。。。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/05/11/CocoaPosd详解/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/11/Masonry-快速上手autoLayout/" itemprop="url">
                  Masonry:快速上手autoLayout
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-11T15:58:23+08:00" content="2015-05-11">
              2015-05-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS第三方/" itemprop="url" rel="index">
                    <span itemprop="name">iOS第三方</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/05/11/Masonry-快速上手autoLayout/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/11/Masonry-快速上手autoLayout/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>来源：里脊串的开发随笔（在此谢过分享者）</p>
<p>纯手写代码所经历的关于页面布局的三个时期</p>
<pre><code>MagicNumber -&gt; autoresizingMask -&gt; autolayout
</code></pre>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/05/11/Masonry-快速上手autoLayout/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/20/MVC设计模式小节/" itemprop="url">
                  iOS中的MVC设计模式理解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-20T17:14:35+08:00" content="2015-04-20">
              2015-04-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/04/20/MVC设计模式小节/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/04/20/MVC设计模式小节/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>模型-视图-控制器（Model-View-Controller，MVC）是Xerox PARC在20世纪80年代为编程语言Smalltalk-80发明的一种软件设计模式，至今已广泛应用于用户交互应用程序中。在iOS开发中MVC的机制被使用的淋漓尽致，充分理解iOS的MVC模式，有助于我们程序的组织合理性。<br><img src="http://7xrz9m.com1.z0.glb.clouddn.com/MVC.png" alt="MVC"><br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2015/04/20/MVC设计模式小节/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="孙聚德" />
          <p class="site-author-name" itemprop="name">孙聚德</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">26</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">孙聚德</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"sunjude"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
